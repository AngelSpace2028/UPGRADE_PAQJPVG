exec("""\n#!/usr/bin/env python3\na='inf'\nZ=ImportError\nX=True\nW=ord\nV=list\nU=min\nT=float\nS=int\nR=all\nQ=open\nO=b'\\x00'\nM=input\nN=Exception\nL=sum\nJ=False\nG=None\nF=print\nE=b''\nD=bytearray\nC=bytes\nB=range\nA=len\nimport os,math,random as H\nfrom typing import Optional,List\ntry:import paq as I\nexcept Z:I=G\ntry:import zstandard as Y;b=Y.ZstdCompressor(level=22);c=Y.ZstdDecompressor();K=X\nexcept Z:K=J\nd='PAQJP_8.2_LOSSLESS_256_TRANSFORMS'\ne=[A for A in B(2,256)if R(A%B!=0 for B in B(2,S(A**.5)+1))]\nf=[79,17,111]\nclass i:\n	def __init__(A):A.table=[[1,2,1,0],[3,5,0,1],[4,6,2,0],[7,10,0,2],[8,12,3,0],[9,13,1,1],[11,14,0,3],[15,19,4,0],[16,23,2,1],[17,24,2,1],[18,25,2,1],[20,27,1,2],[21,28,1,2],[22,29,1,2],[26,30,0,4],[31,33,5,0],[32,34,3,1],[35,37,1,3],[36,38,1,3],[39,42,0,5],[40,43,4,1],[41,44,2,2],[45,48,1,4],[46,49,1,4],[47,50,1,4],[51,52,0,6],[53,55,6,0],[54,56,4,1],[57,59,2,3],[58,60,2,3],[61,63,0,7],[62,64,5,1],[65,66,3,2],[67,69,1,5],[68,70,1,5],[71,73,0,8],[72,74,6,1],[75,76,4,2],[77,78,2,4],[79,80,2,4],[81,82,0,9],[83,84,7,1],[85,86,5,2],[87,88,3,3],[89,90,1,6],[91,92,0,10],[93,94,8,1],[95,96,6,2],[97,98,4,3],[99,100,2,5],[101,102,0,11],[103,104,9,1],[105,106,7,2],[107,108,5,3],[109,110,3,4],[111,112,1,7],[113,114,0,12],[115,116,10,1],[117,118,8,2],[119,120,6,3],[121,122,4,4],[123,124,2,6],[125,126,0,13],[127,128,11,1],[129,130,9,2],[131,132,7,3],[133,134,5,4],[135,136,3,5],[137,138,1,8],[139,140,0,14],[141,142,12,1],[143,144,10,2],[145,146,8,3],[147,148,6,4],[149,150,4,5],[151,152,2,7],[153,154,0,15],[155,156,13,1],[157,158,11,2],[159,160,9,3],[161,162,7,4],[163,164,5,5],[165,166,3,6],[167,168,1,9],[169,170,0,16],[171,172,14,1],[173,174,12,2],[175,176,10,3],[177,178,8,4],[179,180,6,5],[181,182,4,6],[183,184,2,8],[185,186,0,17],[187,188,15,1],[189,190,13,2],[191,192,11,3],[193,194,9,4],[195,196,7,5],[197,198,5,6],[199,200,3,7],[201,202,1,10],[203,204,0,18],[205,206,16,1],[207,208,14,2],[209,210,12,3],[211,212,10,4],[213,214,8,5],[215,216,6,6],[217,218,4,7],[219,220,2,9],[221,222,0,19],[223,224,17,1],[225,226,15,2],[227,228,13,3],[229,230,11,4],[231,232,9,5],[233,234,7,6],[235,236,5,7],[237,238,3,8],[239,240,1,11],[241,242,0,20],[243,244,18,1],[245,246,16,2],[247,248,14,3],[249,250,12,4],[251,252,10,5],[253,254,8,6],[255,255,6,7]]\ndef P(n):\n	D=0\n	while X:\n		A,C=n-D,n+D\n		if A>=2 and R(A%B!=0 for B in B(2,S(A**.5)+1)):return A\n		if C>=2 and R(C%A!=0 for A in B(2,S(C**.5)+1)):return C\n		D+=1\nclass g:\n	def __init__(A):A.PI_DIGITS=f.copy();A.seed_tables=A._gen_seed_tables();A.fibonacci=A._gen_fib(100)\n	def _gen_fib(E,n):\n		C,A=0,1;D=[C,A]\n		for F in B(2,n):C,A=A,C+A;D.append(A)\n		return D\n	def _gen_seed_tables(A,num=126,size=256,seed=42):H.seed(seed);return[[H.randint(5,255)for A in B(size)]for A in B(num)]\n	def get_seed(B,idx,val):\n		if 0<=idx<A(B.seed_tables):return B.seed_tables[idx][val%256]\n		return 0\n	def _append_bits(C,bitlist,value,count):\n		for A in B(count-1,-1,-1):bitlist.append(value>>A&1)\n	def _read_bits(E,bits,pos,count):\n		C=0\n		for D in B(count):\n			if pos+D>=A(bits):return 0\n			C=C<<1|bits[pos+D]\n		return C\n	def transform_00(Y,data):\n		H=data\n		if not H:return O\n		J=G;K=T(a);L=[];Z=10;M=D(H);S=[]\n		for c in B(Z):\n			N=0;P=M;U=T('-inf')\n			for V in B(256):\n				E=D(M)\n				for W in B(A(E)):E[W]=(E[W]+V)%256\n				Q=0;F=0\n				while F<A(E):\n					b=E[F];R=1;F+=1\n					while F<A(E)and E[F]==b:R+=1;F+=1\n					Q+=R*R\n				if Q>U:U=Q;P=E;N=V\n			S.append(N);I=Y._apply_rle_to_shifted(P,N)\n			if A(I)<K:K=A(I);J=I;L=S.copy()\n			M=P\n			if A(I)>=A(H):break\n		if J is G or K>=A(H):return C([0])+H\n		X=D([A(L)]);X.extend(L);return X+J\n	def _apply_rle_to_shifted(F,shifted_data,shift):\n		J=shifted_data;E=[];F._append_bits(E,2,3);F._append_bits(E,shift,8);H=0;L=A(J)\n		while H<L:\n			I=J[H];G=1;H+=1\n			while H<L and J[H]==I:G+=1;H+=1\n			while G>=13:M=U(G,268);F._append_bits(E,15,4);F._append_bits(E,M-13,8);F._append_bits(E,I,8);G-=M\n			if G==1:F._append_bits(E,0,2);F._append_bits(E,I,8)\n			elif G<=5:F._append_bits(E,1,2);F._append_bits(E,G-2,2);F._append_bits(E,I,8)\n			elif G<=12:F._append_bits(E,2,2);F._append_bits(E,G-6,3);F._append_bits(E,I,8)\n		Q=(8-A(E)%8)%8;F._append_bits(E,0,Q);N=D()\n		for O in B(0,A(E),8):\n			K=0\n			for P in B(8):\n				if O+P<A(E):K=K<<1|E[O+P]\n			N.append(K)\n		return C(N)\n	def reverse_transform_00(L,cdata):\n		F=cdata\n		if not F or F==O:return E\n		if F[0]==0:return F[1:]\n		H=F[0]\n		if H==0 or A(F)<1+H:return E\n		M=V(F[1:1+H]);N=F[1+H:];J=L._rle_decode(N)\n		if J is G:return E\n		I=D(J)\n		for P in reversed(M):\n			for K in B(A(I)):I[K]=(I[K]-P)%256\n		return C(I)\n	def _rle_decode(G,data):\n		if not data:return\n		E=[]\n		for L in data:\n			for I in B(7,-1,-1):E.append(L>>I&1)\n		C=0;F=A(E)\n		if F<11:return\n		M=G._read_bits(E,C,3);C+=3\n		if M!=2:return\n		C+=8;K=D()\n		while C+10<=F:\n			J=G._read_bits(E,C,2);C+=2\n			if J==0:H=1\n			elif J==1:\n				if C+2>F:break\n				H=2+G._read_bits(E,C,2);C+=2\n			elif J==2:\n				if C+3>F:break\n				H=6+G._read_bits(E,C,3);C+=3\n			else:\n				if C+2>F:break\n				if G._read_bits(E,C,2)!=3:return\n				C+=2\n				if C+8>F:break\n				H=13+G._read_bits(E,C,8);C+=8\n			if C+8>F:break\n			N=G._read_bits(E,C,8);C+=8;K.extend([N]*H)\n		O=F-C\n		if O>7:return\n		for I in B(C,F):\n			if E[I]!=0:return\n		return K\n	def transform_01(I,d,r=100):\n		E=D(d)\n		for F in e:\n			H=F if F==2 else max(1,math.ceil(F*4096/28672))\n			for J in B(r):\n				for G in B(0,A(E),3):\n					if G<A(E):E[G]^=H\n		return C(E)\n	def reverse_transform_01(A,d,r=100):return A.transform_01(d,r)\n	def transform_02(J,d):\n		if A(d)<1:return E\n		F=D(d);K=L(d)%256;H=(A(d)+K)%256;I=J._get_pattern(4,H)\n		for G in B(1,A(F),4):\n			if G<A(F):F[G]^=I[G%A(I)]\n		return C([H])+C(F)\n	def reverse_transform_02(I,d):\n		if A(d)<2:return E\n		J=d[0];F=D(d[1:]);H=I._get_pattern(4,J)\n		for G in B(1,A(F),4):\n			if G<A(F):F[G]^=H[G%A(H)]\n		return C(F)\n	def transform_03(I,d):\n		if A(d)<1:return E\n		F=D(d);G=(A(d)*13+L(d))%8\n		if G==0:G=1\n		for H in B(2,A(F),5):\n			if H<A(F):F[H]=(F[H]<<G|F[H]>>8-G)&255\n		return C([G])+C(F)\n	def reverse_transform_03(I,d):\n		if A(d)<2:return E\n		H=d[0];F=D(d[1:])\n		for G in B(2,A(F),5):\n			if G<A(F):F[G]=(F[G]>>H|F[G]<<8-H)&255\n		return C(F)\n	def transform_04(G,d,r=100):\n		E=D(d)\n		for H in B(r):\n			for F in B(A(E)):E[F]=(E[F]-F%256)%256\n		return C(E)\n	def reverse_transform_04(G,d,r=100):\n		E=D(d)\n		for H in B(r):\n			for F in B(A(E)):E[F]=(E[F]+F%256)%256\n		return C(E)\n	def transform_05(G,d,s=3):\n		E=D(d)\n		for F in B(A(E)):E[F]=(E[F]<<s|E[F]>>8-s)&255\n		return C(E)\n	def reverse_transform_05(G,d,s=3):\n		E=D(d)\n		for F in B(A(E)):E[F]=(E[F]>>s|E[F]<<8-s)&255\n		return C(E)\n	def transform_06(I,d,sd=42):\n		H.seed(sd);F=V(B(256));H.shuffle(F);E=D(d)\n		for G in B(A(E)):E[G]=F[E[G]]\n		return C(E)\n	def reverse_transform_06(J,d,sd=42):\n		H.seed(sd);G=V(B(256));H.shuffle(G);I=[0]*256\n		for E in B(256):I[G[E]]=E\n		F=D(d)\n		for E in B(A(F)):F[E]=I[F[E]]\n		return C(F)\n	def transform_07(G,d,r=100):\n		E=D(d);H=A(d)%A(G.PI_DIGITS);I=G.PI_DIGITS[H:]+G.PI_DIGITS[:H];J=A(d)%256\n		for F in B(A(E)):E[F]^=J\n		for K in B(r):\n			for F in B(A(E)):E[F]^=I[F%A(I)]\n		return C(E)\n	def reverse_transform_07(A,d,r=100):return A.transform_07(d,r)\n	def transform_08(G,d,r=100):\n		E=D(d);H=A(d)%A(G.PI_DIGITS);I=G.PI_DIGITS[H:]+G.PI_DIGITS[:H];J=P(A(d)%256)\n		for F in B(A(E)):E[F]^=J\n		for K in B(r):\n			for F in B(A(E)):E[F]^=I[F%A(I)]\n		return C(E)\n	def reverse_transform_08(A,d,r=100):return A.transform_08(d,r)\n	def transform_09(E,d,r=100):\n		F=D(d);H=A(d)%A(E.PI_DIGITS);I=E.PI_DIGITS[H:]+E.PI_DIGITS[:H];J=P(A(d)%256);K=E.get_seed(A(d)%A(E.seed_tables),A(d))\n		for G in B(A(F)):F[G]^=J^K\n		for L in B(r):\n			for G in B(A(F)):F[G]^=I[G%A(I)]^G%256\n		return C(F)\n	def reverse_transform_09(A,d,r=100):return A.transform_09(d,r)\n	def transform_10(I,d,r=100):\n		G=L(1 for A in B(A(d)-1)if d[A:A+2]==b'X1');F=(G*2+1)//3*3%256;E=D(d)\n		for J in B(r):\n			for H in B(A(E)):E[H]^=F\n		return C([F])+C(E)\n	def reverse_transform_10(I,d,r=100):\n		if A(d)<1:return E\n		G=d[0];F=D(d[1:])\n		for J in B(r):\n			for H in B(A(F)):F[H]^=G\n		return C(F)\n	def transform_11(I,d,r=100):\n		if not d:return E\n		G=D(d);H=A(G)\n		for N in B(r):\n			for F in B(H):J=(F+H)%A(I.fibonacci);K=I.fibonacci[J]%256;L=(F*13+H*17)%256;M=G[F-1]if F>0 else H%256;G[F]=(G[F]^K^L^M)%256\n		return C(G)\n	def reverse_transform_11(I,d,r=100):\n		if not d:return E\n		G=D(d);H=A(G)\n		for N in B(r):\n			for F in B(H-1,-1,-1):J=(F+H)%A(I.fibonacci);K=I.fibonacci[J]%256;L=(F*13+H*17)%256;M=G[F-1]if F>0 else H%256;G[F]=(G[F]^K^L^M)%256\n		return C(G)\n	def transform_12(F,d,r=100):\n		E=D(d)\n		for H in B(r):\n			for G in B(A(E)):E[G]^=F.fibonacci[G%A(F.fibonacci)]%256\n		return C(E)\n	def reverse_transform_12(A,d,r=100):return A.transform_12(d,r)\n	def transform_13(K,d):\n		if not d:return E\n		I=K._calculate_repeats(d);F=A(d)%256;G=[];J=0\n		while J<I:F=P(F);G.append(F);J+=1\n		H=D(d);L=G[-1]if G else 0\n		for M in B(A(H)):H[M]^=L\n		N=(I-1)%256;return C([N])+C(H)\n	def reverse_transform_13(N,d):\n		if A(d)<2:return E\n		K=d[0];G=(K+1)%256\n		if G==0:G=256\n		F=D(d[1:]);H=A(F)%256;I=[];J=0\n		while J<G:H=P(H);I.append(H);J+=1\n		L=I[-1]if I else 0\n		for M in B(A(F)):F[M]^=L\n		return C(F)\n	def transform_14(A,d):\n		if not d:return O\n		B=A._calculate_bits_to_add(d);D=A._add_bits_to_end(d,B);return C([B])+D\n	def reverse_transform_14(C,d):\n		if A(d)<1:return E\n		D=d[0];B=d[1:]\n		if not B:return E\n		return B[:-1]\n	def transform_15(J,d):\n		if A(d)<1:return E\n		F=D(d);H=A(d)%256;I=J._get_pattern(3,H)\n		for G in B(0,A(F),3):\n			if G<A(F):F[G]=(F[G]+I[G%A(I)])%256\n		return C([H])+C(F)\n	def reverse_transform_15(I,d):\n		if A(d)<2:return E\n		J=d[0];F=D(d[1:]);H=I._get_pattern(3,J)\n		for G in B(0,A(F),3):\n			if G<A(F):F[G]=(F[G]-H[G%A(H)])%256\n		return C(F)\n	def transform_255(A,d):return d\n	def reverse_transform_255(A,d):return d\n	def _calculate_bits_to_add(G,data):\n		B=data\n		if not B:return 0\n		C=A(B);D=B[0];E=B[-1];F=L(B)%256;return(C*13+D*17+E*23+F*29)%9\n	def _add_bits_to_end(G,data,bits_count):\n		B=bits_count;A=data\n		if B==0:return A+O\n		if not A:A=O\n		D=A[-1];E=D&(1<<B)-1;F=(B&15)<<4|E&15;return A+C([F])\n	def _get_pattern(A,size,index):H.seed(12345+size*100+index);return[H.randint(0,255)for A in B(size)]\n	def _calculate_repeats(F,data):\n		B=data\n		if not B:return 1\n		C=A(B);D=L(B)%256;E=(C*13+D*17)%256+1;return max(1,U(256,E))\n	def _dynamic_transform(H,n):\n		def F(data):\n			F=data\n			if not F:return E\n			I=H.get_seed(n%A(H.seed_tables),A(F));G=D(F)\n			for J in B(A(G)):G[J]^=I\n			return C(G)\n		return F,F\n	def _compress_backend(F,data):\n		C=data;B=[]\n		if I is not G:\n			try:B.append((b'L',I.compress(C)))\n			except:pass\n		if K:\n			try:B.append((b'Z',b.compress(C)))\n			except:pass\n		if not B:return b'N'+C\n		D,E=U(B,key=lambda x:A(x[1]));return D+E\n	def _decompress_backend(E,data):\n		B=data\n		if A(B)<1:return\n		C=B[0];D=B[1:]\n		if C==W('L')and I is not G:\n			try:return I.decompress(D)\n			except:return\n		if C==W('Z')and K:\n			try:return c.decompress(D)\n			except:return\n		if C==W('N'):return D\n	def self_test(D):\n		F('Running FULL self‑test to verify ALL transforms (0‑255) are lossless...');I=X;M=[(0,D.transform_00,D.reverse_transform_00),(1,D.transform_01,D.reverse_transform_01),(2,D.transform_02,D.reverse_transform_02),(3,D.transform_03,D.reverse_transform_03),(4,D.transform_04,D.reverse_transform_04),(5,D.transform_05,D.reverse_transform_05),(6,D.transform_06,D.reverse_transform_06),(7,D.transform_07,D.reverse_transform_07),(8,D.transform_08,D.reverse_transform_08),(9,D.transform_09,D.reverse_transform_09),(10,D.transform_10,D.reverse_transform_10),(11,D.transform_11,D.reverse_transform_11),(12,D.transform_12,D.reverse_transform_12),(13,D.transform_13,D.reverse_transform_13),(14,D.transform_14,D.reverse_transform_14),(15,D.transform_15,D.reverse_transform_15)]\n		for T in B(16,255):K,L=D._dynamic_transform(T);M.append((T,K,L))\n		M.append((255,D.transform_255,D.reverse_transform_255));F(f"  Testing {A(M)} transforms (0‑255)...")\n		for(G,K,L)in M:\n			if G==0:continue\n			try:\n				O=K(E);P=L(O)\n				if P!=E:F(f"  [FAIL] Transform {G} empty data");I=J\n			except N:F(f"  [FAIL] Transform {G} empty data (exception)");I=J\n		for(G,K,L)in M:\n			for S in B(256):\n				U=C([S])\n				try:O=K(U);P=L(O)\n				except N:F(f"  [FAIL] Transform {G} byte 0x{S:02x} (exception)");I=J;break\n				if P!=U:F(f"  [FAIL] Transform {G} byte 0x{S:02x}");I=J;break\n			else:\n				if G<=15 or G%50==0 or G==255:F(f"  [PASS] Transform {G} all single bytes")\n		H.seed(123)\n		for(G,K,L)in M:\n			for a in B(5):\n				Q=H.randint(1,100);R=C(H.getrandbits(8)for A in B(Q))\n				try:O=K(R);P=L(O)\n				except N:F(f"  [FAIL] Transform {G} random size {Q} (exception)");I=J;break\n				if P!=R:F(f"  [FAIL] Transform {G} random size {Q}");I=J;break\n			else:\n				if G<=15 or G%50==0 or G==255:F(f"  [PASS] Transform {G} random short data")\n		F('\\n  Testing full compression/decompression pipeline on random data...');H.seed(456)\n		for V in B(100):\n			Q=H.randint(1,500);R=C(H.getrandbits(8)for A in B(Q))\n			try:W=D.compress_with_best(R);Y,Z=D.decompress_with_best(W)\n			except N:F(f"  [FAIL] Pipeline test #{V+1} (exception)");I=J;break\n			if Y!=R:F(f"  [FAIL] Pipeline test #{V+1} (marker {Z})");I=J;break\n		else:F('  [PASS] Full pipeline (100 random inputs)')\n		if I:F('\\n[PASS] Self‑test PASSED – all transforms 0‑255 are 100% lossless.\\n')\n		else:F('\\n[FAIL] Self‑test FAILED – please report this bug!\\n')\n		return I\n	def compress_with_best(D,data):\n		if not data:return C([255])+D._compress_backend(E)\n		F=G;H=T(a);I=255;L=[(0,D.transform_00),(1,D.transform_01),(2,D.transform_02),(3,D.transform_03),(4,D.transform_04),(5,D.transform_05),(6,D.transform_06),(7,D.transform_07),(8,D.transform_08),(9,D.transform_09),(10,D.transform_10),(11,D.transform_11),(12,D.transform_12),(13,D.transform_13),(14,D.transform_14),(15,D.transform_15)]+[(A,D._dynamic_transform(A)[0])for A in B(16,255)]+[(255,D.transform_255)]\n		for(M,O)in L:\n			try:\n				P=O(data);J=D._compress_backend(P);K=A(J)\n				if K<H:H=K;F=J;I=M\n			except N:continue\n		return C([I])+F\n	def decompress_with_best(C,data):\n		D=data\n		if A(D)<2:return E,G\n		H=D[0];K=D[1:];I=C._decompress_backend(K)\n		if I is G:return E,G\n		F={0:C.reverse_transform_00,1:C.reverse_transform_01,2:C.reverse_transform_02,3:C.reverse_transform_03,4:C.reverse_transform_04,5:C.reverse_transform_05,6:C.reverse_transform_06,7:C.reverse_transform_07,8:C.reverse_transform_08,9:C.reverse_transform_09,10:C.reverse_transform_10,11:C.reverse_transform_11,12:C.reverse_transform_12,13:C.reverse_transform_13,14:C.reverse_transform_14,15:C.reverse_transform_15}\n		for J in B(16,255):F[J]=C._dynamic_transform(J)[1]\n		F[255]=C.reverse_transform_255;L=F.get(H,lambda x:x);return L(I),H\n	def compress(J,infile,outfile):\n		H=outfile\n		with Q(infile,'rb')as C:B=C.read()\n		D=J.compress_with_best(B)\n		with Q(H,'wb')as C:C.write(D)\n		L=(1-A(D)/A(B))*100 if B else 0\n		if I is G and not K:E=' (no compression backend - raw storage used)'\n		elif K:E=' (zstd)'\n		else:E=' (paq only)'\n		F(f"Compressed {A(B)} -> {A(D)} bytes ({L:.2f}% saved){E} -> {H}")\n	def decompress(H,infile,outfile):\n		D=outfile\n		with Q(infile,'rb')as C:I=C.read()\n		B,J=H.decompress_with_best(I)\n		if B is G or B==E:F('Decompression failed!');return\n		with Q(D,'wb')as C:C.write(B)\n		F(f"Decompressed (transform {J}) -> {D} ({A(B)} bytes)")\ndef h():\n	E='Output file: ';F(f"{d} - fully lossless, all transforms 0‑255 verified");B=g()\n	if not B.self_test():F('Self‑test failed – compressor is unreliable. Exiting.');return\n	D=M('1) Compress   2) Decompress\\n> ').strip()\n	if D=='1':A=M('Input file: ').strip();C=M(E).strip()or A+'.pjp';B.compress(A,C)\n	elif D=='2':A=M('Compressed file: ').strip();C=M(E).strip()or A.rsplit('.',1)[0]+'.orig';B.decompress(A,C)\n	else:F('Invalid choice.')\nif __name__=='__main__':h()\n""")
