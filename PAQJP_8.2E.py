exec """\n#!/usr/bin/env python3\nb='inf'\na=FileNotFoundError\nZ=ImportError\nX=True\nW=ord\nV=list\nU=min\nT=float\nS=int\nR=all\nQ=open\nO=b'\\x00'\nN=input\nM=sum\nK=False\nI=Exception\nG=None\nF=b''\nE=print\nD=bytearray\nC=bytes\nB=range\nA=len\nimport os,math,random as H\nfrom typing import Optional,List\ntry:import paq as J\nexcept Z:J=G\ntry:import zstandard as Y;c=Y.ZstdCompressor(level=22);d=Y.ZstdDecompressor();L=X\nexcept Z:L=K\ne='PAQJP_8.2_LOSSLESS_256_TRANSFORMS'\nf=[A for A in B(2,256)if R(A%B!=0 for B in B(2,S(A**.5)+1))]\ng=[79,17,111]\nclass j:\n	def __init__(A):A.table=[[1,2,1,0],[3,5,0,1],[4,6,2,0],[7,10,0,2],[8,12,3,0],[9,13,1,1],[11,14,0,3],[15,19,4,0],[16,23,2,1],[17,24,2,1],[18,25,2,1],[20,27,1,2],[21,28,1,2],[22,29,1,2],[26,30,0,4],[31,33,5,0],[32,34,3,1],[35,37,1,3],[36,38,1,3],[39,42,0,5],[40,43,4,1],[41,44,2,2],[45,48,1,4],[46,49,1,4],[47,50,1,4],[51,52,0,6],[53,55,6,0],[54,56,4,1],[57,59,2,3],[58,60,2,3],[61,63,0,7],[62,64,5,1],[65,66,3,2],[67,69,1,5],[68,70,1,5],[71,73,0,8],[72,74,6,1],[75,76,4,2],[77,78,2,4],[79,80,2,4],[81,82,0,9],[83,84,7,1],[85,86,5,2],[87,88,3,3],[89,90,1,6],[91,92,0,10],[93,94,8,1],[95,96,6,2],[97,98,4,3],[99,100,2,5],[101,102,0,11],[103,104,9,1],[105,106,7,2],[107,108,5,3],[109,110,3,4],[111,112,1,7],[113,114,0,12],[115,116,10,1],[117,118,8,2],[119,120,6,3],[121,122,4,4],[123,124,2,6],[125,126,0,13],[127,128,11,1],[129,130,9,2],[131,132,7,3],[133,134,5,4],[135,136,3,5],[137,138,1,8],[139,140,0,14],[141,142,12,1],[143,144,10,2],[145,146,8,3],[147,148,6,4],[149,150,4,5],[151,152,2,7],[153,154,0,15],[155,156,13,1],[157,158,11,2],[159,160,9,3],[161,162,7,4],[163,164,5,5],[165,166,3,6],[167,168,1,9],[169,170,0,16],[171,172,14,1],[173,174,12,2],[175,176,10,3],[177,178,8,4],[179,180,6,5],[181,182,4,6],[183,184,2,8],[185,186,0,17],[187,188,15,1],[189,190,13,2],[191,192,11,3],[193,194,9,4],[195,196,7,5],[197,198,5,6],[199,200,3,7],[201,202,1,10],[203,204,0,18],[205,206,16,1],[207,208,14,2],[209,210,12,3],[211,212,10,4],[213,214,8,5],[215,216,6,6],[217,218,4,7],[219,220,2,9],[221,222,0,19],[223,224,17,1],[225,226,15,2],[227,228,13,3],[229,230,11,4],[231,232,9,5],[233,234,7,6],[235,236,5,7],[237,238,3,8],[239,240,1,11],[241,242,0,20],[243,244,18,1],[245,246,16,2],[247,248,14,3],[249,250,12,4],[251,252,10,5],[253,254,8,6],[255,255,6,7]]\ndef P(n):\n	D=0\n	while X:\n		A,C=n-D,n+D\n		if A>=2 and R(A%B!=0 for B in B(2,S(A**.5)+1)):return A\n		if C>=2 and R(C%A!=0 for A in B(2,S(C**.5)+1)):return C\n		D+=1\nclass h:\n	def __init__(A):A.PI_DIGITS=g.copy();A.seed_tables=A._gen_seed_tables();A.fibonacci=A._gen_fib(100)\n	def _gen_fib(E,n):\n		C,A=0,1;D=[C,A]\n		for F in B(2,n):C,A=A,C+A;D.append(A)\n		return D\n	def _gen_seed_tables(A,num=126,size=256,seed=42):H.seed(seed);return[[H.randint(5,255)for A in B(size)]for A in B(num)]\n	def get_seed(B,idx,val):\n		if 0<=idx<A(B.seed_tables):return B.seed_tables[idx][val%256]\n		return 0\n	def _append_bits(C,bitlist,value,count):\n		for A in B(count-1,-1,-1):bitlist.append(value>>A&1)\n	def _read_bits(E,bits,pos,count):\n		C=0\n		for D in B(count):\n			if pos+D>=A(bits):return 0\n			C=C<<1|bits[pos+D]\n		return C\n	def transform_00(Y,data):\n		H=data\n		if not H:return O\n		J=G;K=T(b);L=[];Z=10;M=D(H);S=[]\n		for c in B(Z):\n			N=0;P=M;U=T('-inf')\n			for V in B(256):\n				E=D(M)\n				for W in B(A(E)):E[W]=(E[W]+V)%256\n				Q=0;F=0\n				while F<A(E):\n					a=E[F];R=1;F+=1\n					while F<A(E)and E[F]==a:R+=1;F+=1\n					Q+=R*R\n				if Q>U:U=Q;P=E;N=V\n			S.append(N);I=Y._apply_rle_to_shifted(P,N)\n			if A(I)<K:K=A(I);J=I;L=S.copy()\n			M=P\n			if A(I)>=A(H):break\n		if J is G or K>=A(H):return C([0])+H\n		X=D([A(L)]);X.extend(L);return X+J\n	def _apply_rle_to_shifted(F,shifted_data,shift):\n		J=shifted_data;E=[];F._append_bits(E,2,3);F._append_bits(E,shift,8);H=0;L=A(J)\n		while H<L:\n			I=J[H];G=1;H+=1\n			while H<L and J[H]==I:G+=1;H+=1\n			while G>=13:M=U(G,268);F._append_bits(E,15,4);F._append_bits(E,M-13,8);F._append_bits(E,I,8);G-=M\n			if G==1:F._append_bits(E,0,2);F._append_bits(E,I,8)\n			elif G<=5:F._append_bits(E,1,2);F._append_bits(E,G-2,2);F._append_bits(E,I,8)\n			elif G<=12:F._append_bits(E,2,2);F._append_bits(E,G-6,3);F._append_bits(E,I,8)\n		Q=(8-A(E)%8)%8;F._append_bits(E,0,Q);N=D()\n		for O in B(0,A(E),8):\n			K=0\n			for P in B(8):\n				if O+P<A(E):K=K<<1|E[O+P]\n			N.append(K)\n		return C(N)\n	def reverse_transform_00(L,cdata):\n		E=cdata\n		if not E or E==O:return F\n		if E[0]==0:return E[1:]\n		H=E[0]\n		if H==0 or A(E)<1+H:return F\n		M=V(E[1:1+H]);N=E[1+H:];J=L._rle_decode(N)\n		if J is G:return F\n		I=D(J)\n		for P in reversed(M):\n			for K in B(A(I)):I[K]=(I[K]-P)%256\n		return C(I)\n	def _rle_decode(G,data):\n		if not data:return\n		E=[]\n		for L in data:\n			for I in B(7,-1,-1):E.append(L>>I&1)\n		C=0;F=A(E)\n		if F<11:return\n		M=G._read_bits(E,C,3);C+=3\n		if M!=2:return\n		C+=8;K=D()\n		while C<F:\n			if C+2>F:break\n			J=G._read_bits(E,C,2);C+=2\n			if J==0:\n				if C+8>F:break\n				H=1\n			elif J==1:\n				if C+2+8>F:break\n				H=2+G._read_bits(E,C,2);C+=2\n			elif J==2:\n				if C+3+8>F:break\n				H=6+G._read_bits(E,C,3);C+=3\n			else:\n				if C+2+8+8>F:break\n				if G._read_bits(E,C,2)!=3:return\n				C+=2;H=13+G._read_bits(E,C,8);C+=8\n			if C+8>F:break\n			N=G._read_bits(E,C,8);C+=8;K.extend([N]*H)\n		for I in B(C,F):\n			if E[I]!=0:return\n		return K\n	def transform_01(I,d,r=100):\n		E=D(d)\n		for F in f:\n			H=F if F==2 else max(1,math.ceil(F*4096/28672))\n			for J in B(r):\n				for G in B(0,A(E),3):\n					if G<A(E):E[G]^=H\n		return C(E)\n	def reverse_transform_01(A,d,r=100):return A.transform_01(d,r)\n	def transform_02(J,d):\n		if A(d)<1:return F\n		E=D(d);K=M(d)%256;H=(A(d)+K)%256;I=J._get_pattern(4,H)\n		for G in B(1,A(E),4):\n			if G<A(E):E[G]^=I[G%A(I)]\n		return C([H])+C(E)\n	def reverse_transform_02(I,d):\n		if A(d)<2:return F\n		J=d[0];E=D(d[1:]);H=I._get_pattern(4,J)\n		for G in B(1,A(E),4):\n			if G<A(E):E[G]^=H[G%A(H)]\n		return C(E)\n	def transform_03(I,d):\n		if A(d)<1:return F\n		E=D(d);G=(A(d)*13+M(d))%8\n		if G==0:G=1\n		for H in B(2,A(E),5):\n			if H<A(E):E[H]=(E[H]<<G|E[H]>>8-G)&255\n		return C([G])+C(E)\n	def reverse_transform_03(I,d):\n		if A(d)<2:return F\n		H=d[0];E=D(d[1:])\n		for G in B(2,A(E),5):\n			if G<A(E):E[G]=(E[G]>>H|E[G]<<8-H)&255\n		return C(E)\n	def transform_04(G,d,r=100):\n		E=D(d)\n		for H in B(r):\n			for F in B(A(E)):E[F]=(E[F]-F%256)%256\n		return C(E)\n	def reverse_transform_04(G,d,r=100):\n		E=D(d)\n		for H in B(r):\n			for F in B(A(E)):E[F]=(E[F]+F%256)%256\n		return C(E)\n	def transform_05(G,d,s=3):\n		E=D(d)\n		for F in B(A(E)):E[F]=(E[F]<<s|E[F]>>8-s)&255\n		return C(E)\n	def reverse_transform_05(G,d,s=3):\n		E=D(d)\n		for F in B(A(E)):E[F]=(E[F]>>s|E[F]<<8-s)&255\n		return C(E)\n	def transform_06(I,d,sd=42):\n		H.seed(sd);F=V(B(256));H.shuffle(F);E=D(d)\n		for G in B(A(E)):E[G]=F[E[G]]\n		return C(E)\n	def reverse_transform_06(J,d,sd=42):\n		H.seed(sd);G=V(B(256));H.shuffle(G);I=[0]*256\n		for E in B(256):I[G[E]]=E\n		F=D(d)\n		for E in B(A(F)):F[E]=I[F[E]]\n		return C(F)\n	def transform_07(G,d,r=100):\n		E=D(d);H=A(d)%A(G.PI_DIGITS);I=G.PI_DIGITS[H:]+G.PI_DIGITS[:H];J=A(d)%256\n		for F in B(A(E)):E[F]^=J\n		for K in B(r):\n			for F in B(A(E)):E[F]^=I[F%A(I)]\n		return C(E)\n	def reverse_transform_07(A,d,r=100):return A.transform_07(d,r)\n	def transform_08(G,d,r=100):\n		E=D(d);H=A(d)%A(G.PI_DIGITS);I=G.PI_DIGITS[H:]+G.PI_DIGITS[:H];J=P(A(d)%256)\n		for F in B(A(E)):E[F]^=J\n		for K in B(r):\n			for F in B(A(E)):E[F]^=I[F%A(I)]\n		return C(E)\n	def reverse_transform_08(A,d,r=100):return A.transform_08(d,r)\n	def transform_09(E,d,r=100):\n		F=D(d);H=A(d)%A(E.PI_DIGITS);I=E.PI_DIGITS[H:]+E.PI_DIGITS[:H];J=P(A(d)%256);K=E.get_seed(A(d)%A(E.seed_tables),A(d))\n		for G in B(A(F)):F[G]^=J^K\n		for L in B(r):\n			for G in B(A(F)):F[G]^=I[G%A(I)]^G%256\n		return C(F)\n	def reverse_transform_09(A,d,r=100):return A.transform_09(d,r)\n	def transform_10(I,d,r=100):\n		G=M(1 for A in B(A(d)-1)if d[A:A+2]==b'X1');F=(G*2+1)//3*3%256;E=D(d)\n		for J in B(r):\n			for H in B(A(E)):E[H]^=F\n		return C([F])+C(E)\n	def reverse_transform_10(I,d,r=100):\n		if A(d)<1:return F\n		G=d[0];E=D(d[1:])\n		for J in B(r):\n			for H in B(A(E)):E[H]^=G\n		return C(E)\n	def transform_11(I,d,r=100):\n		if not d:return F\n		G=D(d);H=A(G)\n		for N in B(r):\n			for E in B(H):J=(E+H)%A(I.fibonacci);K=I.fibonacci[J]%256;L=(E*13+H*17)%256;M=G[E-1]if E>0 else H%256;G[E]=(G[E]^K^L^M)%256\n		return C(G)\n	def reverse_transform_11(I,d,r=100):\n		if not d:return F\n		G=D(d);H=A(G)\n		for N in B(r):\n			for E in B(H-1,-1,-1):J=(E+H)%A(I.fibonacci);K=I.fibonacci[J]%256;L=(E*13+H*17)%256;M=G[E-1]if E>0 else H%256;G[E]=(G[E]^K^L^M)%256\n		return C(G)\n	def transform_12(F,d,r=100):\n		E=D(d)\n		for H in B(r):\n			for G in B(A(E)):E[G]^=F.fibonacci[G%A(F.fibonacci)]%256\n		return C(E)\n	def reverse_transform_12(A,d,r=100):return A.transform_12(d,r)\n	def transform_13(K,d):\n		if not d:return F\n		I=K._calculate_repeats(d);E=A(d)%256;G=[];J=0\n		while J<I:E=P(E);G.append(E);J+=1\n		H=D(d);L=G[-1]if G else 0\n		for M in B(A(H)):H[M]^=L\n		N=(I-1)%256;return C([N])+C(H)\n	def reverse_transform_13(N,d):\n		if A(d)<2:return F\n		K=d[0];G=(K+1)%256\n		if G==0:G=256\n		E=D(d[1:]);H=A(E)%256;I=[];J=0\n		while J<G:H=P(H);I.append(H);J+=1\n		L=I[-1]if I else 0\n		for M in B(A(E)):E[M]^=L\n		return C(E)\n	def transform_14(A,d):\n		if not d:return O\n		B=A._calculate_bits_to_add(d);D=A._add_bits_to_end(d,B);return C([B])+D\n	def reverse_transform_14(C,d):\n		if A(d)<1:return F\n		D=d[0];B=d[1:]\n		if not B:return F\n		return B[:-1]\n	def transform_15(J,d):\n		if A(d)<1:return F\n		E=D(d);H=A(d)%256;I=J._get_pattern(3,H)\n		for G in B(0,A(E),3):\n			if G<A(E):E[G]=(E[G]+I[G%A(I)])%256\n		return C([H])+C(E)\n	def reverse_transform_15(I,d):\n		if A(d)<2:return F\n		J=d[0];E=D(d[1:]);H=I._get_pattern(3,J)\n		for G in B(0,A(E),3):\n			if G<A(E):E[G]=(E[G]-H[G%A(H)])%256\n		return C(E)\n	def transform_255(A,d):return d\n	def reverse_transform_255(A,d):return d\n	def _calculate_bits_to_add(G,data):\n		B=data\n		if not B:return 0\n		C=A(B);D=B[0];E=B[-1];F=M(B)%256;return(C*13+D*17+E*23+F*29)%9\n	def _add_bits_to_end(G,data,bits_count):\n		B=bits_count;A=data\n		if B==0:return A+O\n		if not A:A=O\n		D=A[-1];E=D&(1<<B)-1;F=(B&15)<<4|E&15;return A+C([F])\n	def _get_pattern(A,size,index):H.seed(12345+size*100+index);return[H.randint(0,255)for A in B(size)]\n	def _calculate_repeats(F,data):\n		B=data\n		if not B:return 1\n		C=A(B);D=M(B)%256;E=(C*13+D*17)%256+1;return max(1,U(256,E))\n	def _dynamic_transform(H,n):\n		def E(data):\n			E=data\n			if not E:return F\n			I=H.get_seed(n%A(H.seed_tables),A(E));G=D(E)\n			for J in B(A(G)):G[J]^=I\n			return C(G)\n		return E,E\n	def _compress_backend(F,data):\n		C=data;B=[]\n		if J is not G:\n			try:B.append((b'L',J.compress(C)))\n			except:pass\n		if L:\n			try:B.append((b'Z',c.compress(C)))\n			except:pass\n		if not B:return b'N'+C\n		D,E=U(B,key=lambda x:A(x[1]));return D+E\n	def _decompress_backend(E,data):\n		B=data\n		if A(B)<1:return\n		C=B[0];D=B[1:]\n		if C==W('L')and J is not G:\n			try:return J.decompress(D)\n			except:return\n		if C==W('Z')and L:\n			try:return d.decompress(D)\n			except:return\n		if C==W('N'):return D\n	def self_test(D):\n		E('Running FULL self‑test to verify ALL transforms (0‑255) are lossless...');J=X;N=[(0,D.transform_00,D.reverse_transform_00),(1,D.transform_01,D.reverse_transform_01),(2,D.transform_02,D.reverse_transform_02),(3,D.transform_03,D.reverse_transform_03),(4,D.transform_04,D.reverse_transform_04),(5,D.transform_05,D.reverse_transform_05),(6,D.transform_06,D.reverse_transform_06),(7,D.transform_07,D.reverse_transform_07),(8,D.transform_08,D.reverse_transform_08),(9,D.transform_09,D.reverse_transform_09),(10,D.transform_10,D.reverse_transform_10),(11,D.transform_11,D.reverse_transform_11),(12,D.transform_12,D.reverse_transform_12),(13,D.transform_13,D.reverse_transform_13),(14,D.transform_14,D.reverse_transform_14),(15,D.transform_15,D.reverse_transform_15)]\n		for T in B(16,255):L,M=D._dynamic_transform(T);N.append((T,L,M))\n		N.append((255,D.transform_255,D.reverse_transform_255));E(f"  Testing {A(N)} transforms (0‑255)...")\n		for(G,L,M)in N:\n			if G==0:continue\n			try:\n				O=L(F);P=M(O)\n				if P!=F:E(f"  [FAIL] Transform {G} empty data");J=K\n			except I:E(f"  [FAIL] Transform {G} empty data (exception)");J=K\n		for(G,L,M)in N:\n			for S in B(256):\n				U=C([S])\n				try:O=L(U);P=M(O)\n				except I:E(f"  [FAIL] Transform {G} byte 0x{S:02x} (exception)");J=K;break\n				if P!=U:E(f"  [FAIL] Transform {G} byte 0x{S:02x}");J=K;break\n			else:\n				if G<=15 or G%50==0 or G==255:E(f"  [PASS] Transform {G} all single bytes")\n		H.seed(123)\n		for(G,L,M)in N:\n			for a in B(5):\n				Q=H.randint(1,100);R=C(H.getrandbits(8)for A in B(Q))\n				try:O=L(R);P=M(O)\n				except I:E(f"  [FAIL] Transform {G} random size {Q} (exception)");J=K;break\n				if P!=R:E(f"  [FAIL] Transform {G} random size {Q}");J=K;break\n			else:\n				if G<=15 or G%50==0 or G==255:E(f"  [PASS] Transform {G} random short data")\n		E('\\n  Testing full compression/decompression pipeline on random data...');H.seed(456)\n		for V in B(100):\n			Q=H.randint(1,500);R=C(H.getrandbits(8)for A in B(Q))\n			try:W=D.compress_with_best(R);Y,Z=D.decompress_with_best(W)\n			except I:E(f"  [FAIL] Pipeline test #{V+1} (exception)");J=K;break\n			if Y!=R:E(f"  [FAIL] Pipeline test #{V+1} (marker {Z})");J=K;break\n		else:E('  [PASS] Full pipeline (100 random inputs)')\n		if J:E('\\n[PASS] Self‑test PASSED – all transforms 0‑255 are 100% lossless.\\n')\n		else:E('\\n[FAIL] Self‑test FAILED – please report this bug!\\n')\n		return J\n	def compress_with_best(D,data):\n		if not data:return C([255])+D._compress_backend(F)\n		E=G;H=T(b);J=255;M=[(0,D.transform_00),(1,D.transform_01),(2,D.transform_02),(3,D.transform_03),(4,D.transform_04),(5,D.transform_05),(6,D.transform_06),(7,D.transform_07),(8,D.transform_08),(9,D.transform_09),(10,D.transform_10),(11,D.transform_11),(12,D.transform_12),(13,D.transform_13),(14,D.transform_14),(15,D.transform_15)]+[(A,D._dynamic_transform(A)[0])for A in B(16,255)]+[(255,D.transform_255)]\n		for(N,O)in M:\n			try:\n				P=O(data);K=D._compress_backend(P);L=A(K)\n				if L<H:H=L;E=K;J=N\n			except I:continue\n		return C([J])+E\n	def decompress_with_best(C,data):\n		D=data\n		if A(D)<2:return F,G\n		H=D[0];L=D[1:];J=C._decompress_backend(L)\n		if J is G:return F,G\n		E={0:C.reverse_transform_00,1:C.reverse_transform_01,2:C.reverse_transform_02,3:C.reverse_transform_03,4:C.reverse_transform_04,5:C.reverse_transform_05,6:C.reverse_transform_06,7:C.reverse_transform_07,8:C.reverse_transform_08,9:C.reverse_transform_09,10:C.reverse_transform_10,11:C.reverse_transform_11,12:C.reverse_transform_12,13:C.reverse_transform_13,14:C.reverse_transform_14,15:C.reverse_transform_15}\n		for K in B(16,255):E[K]=C._dynamic_transform(K)[1]\n		E[255]=C.reverse_transform_255;M=E.get(H,lambda x:x)\n		try:N=M(J)\n		except I:return F,G\n		return N,H\n	def compress(N,infile,outfile):\n		M=infile;C=outfile\n		try:\n			with Q(M,'rb')as D:B=D.read()\n		except a:E(f"Error: input file '{M}' not found.");return\n		except I as F:E(f"Error reading file: {F}");return\n		H=N.compress_with_best(B)\n		try:\n			with Q(C,'wb')as D:D.write(H)\n		except I as F:E(f"Error writing output file: {F}");return\n		if A(B)==0:E(f"Compressed empty file -> {C} (0 bytes)")\n		else:\n			O=(1-A(H)/A(B))*100\n			if J is G and not L:K=' (no compression backend - raw storage used)'\n			elif L:K=' (zstd)'\n			else:K=' (paq only)'\n			E(f"Compressed {A(B)} -> {A(H)} bytes ({O:.2f}% saved){K} -> {C}")\n	def decompress(K,infile,outfile):\n		J=outfile;H=infile\n		try:\n			with Q(H,'rb')as C:L=C.read()\n		except a:E(f"Error: compressed file '{H}' not found.");return\n		except I as D:E(f"Error reading file: {D}");return\n		B,M=K.decompress_with_best(L)\n		if B is G or B==F:E('Decompression failed: invalid compressed data or transform error.');return\n		try:\n			with Q(J,'wb')as C:C.write(B)\n		except I as D:E(f"Error writing output file: {D}");return\n		E(f"Decompressed (transform {M}) -> {J} ({A(B)} bytes)")\ndef i():\n	F='Output file: ';E(f"{e} - fully lossless, all transforms 0‑255 verified");B=h()\n	if not B.self_test():E('Self‑test failed – compressor is unreliable. Exiting.');return\n	D=N('1) Compress   2) Decompress\\n> ').strip()\n	if D=='1':A=N('Input file: ').strip();C=N(F).strip()or A+'.pjp';B.compress(A,C)\n	elif D=='2':A=N('Compressed file: ').strip();C=N(F).strip()or A.rsplit('.',1)[0]+'.orig';B.decompress(A,C)\n	else:E('Invalid choice.')\nif __name__=='__main__':i()\n"""
